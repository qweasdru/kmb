# Local File Inclusion
__LFI__ - это возможность использования и выполнения локальных файлов на серверной стороне. Уязвимость позволяет удаленному пользователю получить доступ с помощью специально сформированного запроса к произвольным файлам на сервере, в том числе содержащую конфиденциальную информацию.

Проще говоря, это уязвимость открытия файлов с сервера + недостаточная фильтрация, что позволяет открывать произвольный файл.

## Поиск file inclusion
Вначале разберемся как определить параметры которые отвечают за инклуд файлов.

__Поиск параметров__  
Для поиска параметров есть два варианта: автоматический или ручной поиск.

__Автоматический поиск__  
Автоматический поиск можно осуществить тем же spider'ом в burpsuite. Вы можете у нас в вики найти статью burpsuite.

__Ручной поиск__  
Сейчас я поговорю о ручном поиске.
Предположим, что мы нашли GET параметр:
```
http://site.ru/folder/index.php?file=gallery
```
Подставим под параметр строку 'index':
```
http://site.ru/folder/index.php?file=index
```
Если у вас открылся какой то из файлов index.(любое расширение), находящихся на сайте, то тут мы уже однозначно можем утверждать, что файл отвечает за подкачку файла.

*__Именно такие параметры нам и нужны.__*

__Определение фильтров__  
После того, как мы получили список параметров, нужно проверить, есть ли у них фильтрация.

__Нулевая фильтрация__  
Попробуем подкачать файлы, которые не рассчитывали показывать=)

Аналогом такого файла в линкусе является файл /etc/passwd

(В данном случае за строку с параметром мы взяли http://site.ru/folder/index.php?file=index.html)

Попробуем его подкачать:
```
http://site.ru/folder/index.php?file=/../../../../../../etc/passwd
```
Объясняю что происходит - переход в папку /../ означает поднятие по иерархии вверх (точнее это уязвимость path traversal). Т.к. папка etc лежит в корневой папке, то мы должны ее достичь угадыванием: то есть чем чаще мы поднимаемся вверх, тем выше шанс, что мы окажемся в корневой папке (то мы должны написать несколько раз /../).

**_Если файл показался. То считайте, что вы нашли LFI._** В этом случае фильтр вообще отсутствует.

__Нулевой байт__  
В данном случае за строку с параметром мы взяли http://site.ru/folder/index.php?file=index, то есть с отсутствующим окончанием.  
Но даже при отсутствии фильтра могут быть проблемы. Например в конце параметра может приписываться окончание.

Например с запросом `/../../../../../../etc/passwd` может преобразоваться в
```
/../../../../../../etc/passwd.php
```
Но и на этот раз есть вариант исправить строку.В старых версиях PHP остался такой недостаток, как `Null Byte Injection`.  
Один из них - это приписывание нулевого байта. Параметры, при передаче по http, зашифровываются в url шифрование. И в этой кодировке нулевой байт выглядит именно в %00.

А т.к. в PHP и многих других языках чтение строки идет именно до нулевого байта, то мы можем приписать его в середину строки, чтобы следующая часть строки отбрасывалась.

В данном случае если мы впишем в параметр `/../../../../../../etc/passwd.php%00`, то получим следующую строку:
```
http://site.ru/folder/index.php?file=/../../../../../../etc/passwd%00
```
И строка в памяти сервера будет выглядеть как:
```
/../../../../../../etc/passwd%00.php ==> /../../../../../../etc/passwd
```
И в итоге мы смогли отбросить окончание и получить нужный файл.

__String limit__  
Еще один вариант отбрасывания окончания возможен при String Limit - укорачиванию строки.  
И какая же от этого польза? А что если мы отбросим часть строки с окончанием, то получится нужная нам строка,но уже без окончания.

Уже на этот раз нам может помочь строка `/./` . Объясняю, что происходит:
```
/./././././index === index
```
Если точнее, то в bash эти две строки идентичны. Приведу пример, как это может помочь
```
1) У нас есть параметр, строка которого укорачивается до 100 символов
2) Попробуем вывести файл index.txt, при условии, что приписывается окончание .php
3) Попробуем ввести index.txt - в итоге выводится index.txt.php
4) Чтобы обойти защиту, нужно ввести index.txt/././././../...<<(100-10)/2 раз>>.../././
5) В итоге получается, что к этой длинной строке приписывается .php, которое в последствии отбрасывается
6) Profit!
```

__php filter__  
По мне самый интересный вариант lfi является lfi с php filter. Сразу привожу пример
```
http://site.ru/folder/index.php?file=php://filter/convert.base64-encode/resource=index
```
В итоге у нас в браузере не запустится php файл, а выведется его base64 исходников.  
Это в последнее время появляется на соревнованиях все чаще и чаще.

## Эксплуатация уязвимости
Если вы читаете этот пункт,то вероятнее всего уже нашли LFI. Тогда разберем, чем она может нам быть полезна.

__Получение важных файлов (не скриптов)__  
Ну самое типичное для lfi - скачивание файлов, которые мы, по задумке администратора, не должны были скачивать. Приведу пример задания:
```
Задание:
    Дан файлообменник, есть несколько аккаунтов - admin и user(и паролем test). Нужно скачать файл flag.txt, хранящийся у аккаунта admin.
Решение:
    1) Загрузим свой файл, и посмотрим на ссылку на его скачивание. Она будет вида http://site.ru/download.php?file=user/image.png
    2) И в правду папка user существует. Но при скачивании по ссылке http://site.ru/user/image.png идет ошибка 403, что вполне логично.
    3) На всякий случай составим ссылку с однозначно отсутствующим файлом в папке user, и если ответ будет 404, то понимаем, что ответ 403 == ответу 200.
    4) Проверим, верно ли, что наш файл должен быть по пути admin/flag.txt: http://site.ru/admin/flag.txt возвращает 403 (вспоминаем предыдущий пункт).
    5) А почему бы, раз скачать не можем, не направить скрипт download.php на нужный нам файл? Пробуем перейти по http://site.ru/download.php?file=admin/flag.txt и получаем файл.
    6) Profit!
```

__Получение исходников__  
В получении исходников могут быть некоторые проблемы. Например, при эксплуатации исходники не высвечиваются, а запускаются. В этом случае к нам на помощь приходит как раз php filter.  
Примеры тут достаточно простые, так что не вижу смысла их приводить.

__LFI -> RCE__  
Т.к. этот раздел уже переходит в более опасный раздел RCE, то вполне логично перенести дискуссию по этому поводу в нее. Ищите на сайте =)

## Множество примеров
__SharifCTF 2016 - technews__

__Описание__  
Can you find the flag?http://ctf.sharif.edu:31455/chal/technews/ca23e03d4c8b9ff6/

__Решение__
```
1. Смотрим путь до картинок, открываем напрямую папку /files/ и видим папку /flag/
2. Проверяем существование файла /files/flag/flag.txt (403 ошибка)
3. Проверив burpsuit'ом замечаем, что некоторые картинки подкачиваются как images.php?id=files/images/heart.jpg
4. При images.php?id = php://filter/convert.base64-encode/resource=files/images/heart.jpg картинка возвращается в незашифрованом виде, что наводит на мысли регулярного выражения.
5. Изучаем форму и обходим регулярку с помощью запроса: images.php?id=php://abcdresource=files/flag/heart.jpg/resource=files/flag/flag.txt
```
(райтап взят с https://ctftime.org/writeup/2404)

## Полезные ссылки
> * https://www.idontplaydarts.com/2011/02/using-php-filter-for-local-file-inclusion/
> * https://xakep.ru/2009/09/17/49508/
> * http://raz0r.name/articles/null-byte-alternative/
> * https://www.owasp.org/index.php/Testing_for_Local_File_Inclusion


----
взято с сайта http://itsecwiki.org/